    Berkeley Yacc is an LALR(1) parser generator.  Berkeley Yacc has been made
as compatible as possible with AT&T Yacc.  Berkeley Yacc can accept any input
specification that conforms to the AT&T Yacc documentation.  Specifications
that take advantage of undocumented features of AT&T Yacc will probably be
rejected.

    Berkeley Yacc is distributed with no warranty whatever.  The code is certain
to contain errors.  Neither the author nor any contributor takes responsibility
for any consequences of its use.

    Berkeley Yacc is in the public domain.  The data structures and algorithms
used in Berkeley Yacc are all either taken from documents available to the
general public or are inventions of the author.  Anyone may freely distribute
source or binary forms of Berkeley Yacc whether unchanged or modified.
Distributers may charge whatever fees they can obtain for Berkeley Yacc.
Programs generated by Berkeley Yacc may be distributed freely.

    Please report bugs to

			  corbett@berkeley.edu

Include a small example if possible.  Please include the banner string from
skeleton.c with the bug report.  Do not expect rapid responses.

prs:
-h: hard-coded generators
-p: predictive parsers LL(1)
-vv: print LR(0) and SLR(1) conflicts on y.output
-kNNN: NNN lookahead tokens for LL(k), only -k makes k=0 i.e. infinite lookahead [TODO]

build tree (as in antlr) [TODO]: %tree and reader.c:read_grammar()

main data strucutures:
    printf("rlhs:"); /* rule left hand side (target symbol number) */
    for (i = 0; i < nrules; ++i) printf(" [%d]=%s", i, symbol_name[rlhs[i]]);
    printf("\nrrhs:"); /* rule right hand side (index into ritem, while > 0) */
    for (i = 0; i < nrules; ++i) printf(" [%d]=%d", i, rrhs[i]);
    printf("\nritem:"); /* right hand side symbols, end with -1*(rule number) */
    for (i = 0; i < nitems; ++i)
      printf(" [%d]=%d(%s)", i, ritem[i],
		ritem[i] > 0 ? symbol_name[ritem[i]] : symbol_name[rlhs[-ritem[i]]]);
    printf("\nderives:"); /* which rules are derived from a non-terminal */
    for (i = ntokens+1; i < nsyms; i++) {
	printf("\n\t[%d]=%s:", i, symbol_name[i]);
	for (sp = derives[i]; *sp >= 0; sp++)
	    printf(" %d", *sp);
    }
    printf("\nterminals:");
    for (i = 0; i < ntokens; i++) printf(" [%d]=%s", i, symbol_name[i]);
    printf("\nnon-terminals:");
    for (i = ntokens; i < nsyms; i++) printf(" [%d]=%s", i, symbol_name[i]);
    printf("\nnullable non-terminals:");
    for (i = ntokens; i < nsyms; i++) if (nullable[i]) printf(" [%d]=%s", i, symbol_name[i]);
    printf("\nrules:");
    for (i = 2; i < nrules; ++i) { /* print rules */
	printf("\n\t%s :", symbol_name[rlhs[i]]);
	for (j = rrhs[i]; ritem[j] > 0; ++j) {
	    printf(" %s", symbol_name[ritem[j]]);
	}
    }
    printf("\n");
